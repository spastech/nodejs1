### Implement "scope factory" for OAuth authenticators

#### Feature description

This feature is meant to support developers who want to use Stormpath for token management (we create the tokens for them, and retain a database of issued tokens), but also want to add custom scope to the access tokens that we issue from the `applications/:appId/oauth/token` endpoint.  Developers want to put custom scope in the access token, because it allows them to quickly do access control checks in their application when validating the access token at a later time.

In this situation, we will "add" the custom scope by creating a new access token, this token will be identical to the original token, except we will add the custom scope as a new claim in the token.  So where a default access token response from our API looks like this:

```javascript
{
  jti: '3xq96rF12hrlb61YSVQwFd',
  iat: 1476749958,
  iss: 'https://staging-api-b.stormpath.com/v1/applications/24k7HnDOz4tQ9ARsBtPUN6',
  sub: 'https://staging-api-b.stormpath.com/v1/accounts/5u8BYZtu09s3yd1XtDYRSo',
  exp: 1476750558,
  rti: '3xq96nuw87YmyGvhGFZfdZ'
}
```

The new access token would look like this:

```javascript
{
  jti: "uUy2ofmqxZHlG2iEvch53",
  iat: 1476749789,
  iss: "https://staging-api-b.stormpath.com/v1/applications/24k7HnDOz4tQ9ARsBtPUN6",
  sub: "https://staging-api-b.stormpath.com/v1/accounts/5u8BYZtu09s3yd1XtDYRSo",
  exp: 1476753388,
  rti: "uUy2lLhwNGJ8Qwr2flQSz",
  scope: "foo"
}
```

In order to pass validation, the new token must be signed with the same signing key as the original token.  This signing key is the Tenant API Key Secret that was used when the original token was created.

To allow the developer to add custom scope, we must add a "scope factory" option to our OAuth authenticators.  The scope factory is a function that is provided by the developer, and we call this function after we have received an access token from the server.  If the developer returns a truthy string value from the scope factory, we must create a new access token, and add the `scope` claim to the body of the new token.  We then replace the original token with the new token on the authentication result. 

#### Requirements

The following authenticator needs to support the scope factory:

* OAuthPasswordGrantRequestAuthenticator
* OAuthClientCredentialsAuthenticator
* OAuthStormpathTokenAuthenticator

Instances of these authenticators must provide a `setScopeFactory` function for defining the scope factory function.  They must also provide a `setScopeFactorySigningKey` to pass in the signing key.  The must also accept a new, optional, `scope` parameter.  This is used to indicate what scope the client or end user is requesting to have.

The signature of the scope factory function should be `(authenticationResult, requestedScope, callback)`:

* The `authenticationResult` is the authentication result that you currently recieve when you call `authenticator.authenticateAccount(function(err, authenticationResult))`.  By passing the entire result to the developer, they can fetch the account and decide what to do.

* The `requestedScope` is the scope the the end-user has requested while authenticating.  It is up to the developer to look at the requested scope and decide what scope the user is permitted to have.

This feature should have integration tests (using staging-api-b.stormpath.com) and we should test the following:

* If a scope factory is provided, assert that the value from the scope factory is added to the access token in the authentication result.
* Assert that all the other fields in the token header and claims body are exactly the same.
* Assert that the new token will pass validation with the `JwtAuthenticator`
* Assert that if a token has scope and passes validation, that that scope will be available as `authenticationResult.expandedJwt.claims.scope`.
* Assert that this also works when `jwtAuthenticator.withLocationValidation()` has been used.
* If the developer provides a scope factory, but not a signing key, we should callback with the error, an error should be provided to the callback of `authenticator.authenticate()`.  We should not throw this error.

See the examples below for more context.

#### Example Scope Factory: "Groups as scope"

A common use-case is to apply the account's groups as the scope of the token, as a list of space seperated names.  To achieve that, the developer could provide a function like this:

```javascript
function groupScopeFactory(authenticationResult, requestedScope, callback){
  authenticationResult.getAccount({expand: 'groups'}, function(err, account){
    if (err) {
      return callback(err);
    }
    
    var groupNames = account.groups.items.map(function (group) {
      return group.name;
    });
    
    var grantedScope = groupNames.join(' ');
    
    callback(null, grantedScope);
  });
}
```

#### Example use-case: Express application

Here is a pseudo Express application that demonstrates how this new scope factory can be used to issue scope, and how that scope can be checked on future requests.


```javascript
var express = require('express');
var stormpath = require('stormpath');

var tenantApiKey = {
  id: 'stormpath tenant api key id',
  secret: 'stormpath tenant api key secret'
}

var stormpathClient = new stormpath.Client({
  apiKey: tenantApiKey
});

var app = express();
var appHref = 'https://staging-api-b.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';
var application;
var clientCredentialsAuthenticator;
var jwtAuthenticator;
var groupScopeFactory; // see previous example above

stormpathClient.getApplication(appHref, function(err, application) {

  if (err) {
    throw err;
  }
  
  clientCredentialsAuthenticator = new stormpath.OAuthClientCredentialsAuthenticator(application);
  clientCredentialsAuthenticator.setScopeFactory(groupScopeFactory);
  clientCredentialsAuthenticator.setScopeFactorySigningKey(tenantApiKey.secret);
  
  jwtAuthenticator = new stormpath.JwtAuthenticator(application);

  // Now that we have authenticators, we can start the server
  app.listen();

});


app.post('/oauth/token', function (req, res, next){
  if (req.body.grant_type !== 'client_credentials') {
    return next(new Error('Unsupported grant type'));
  }

  // This client ID and secret is an API key that has been
  // issued to the end-user's stormpath account, this is not
  // a Tenant API Key


  var authenticationRequest = {
    apiKey: {
     id: req.body.client_id,
     secret: req.body.client_secret
    },
    scope: req.body.scope;
  };

  clientCredentialsAuthenticator.authenticate(authenticationRequest, function(err, authenticationResult) {
    if (err) {
      return next(err);
    }

    res.json(authenticationResult.accessTokenResponse);
  });
});

function requireAdmins(req,res,next) {
  var accessToken; // Pull the access token from the `Authorization: Bearer <token>` location

  jwtAuthenticator.authenticate(accessToken, function (err, authenticationResult) {
    if (err) {
      return next(err);
    }

    if (authenticationResult.accessToken.expandedJwt.claims.scope.match(/admin/)) {
      return next(); // Authorized, OK to proceed
    }

    res.status(403).end();
  });
}

app.get('/admins', requireAdmins, function (req, res, next) {
  res.send('You are an admin');
});
```
